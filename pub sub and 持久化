redis是一种消息通信机制，把消息类型定义为通道


redis持久化
redis持久化技术有两种方式1 snapshotting2aof
1 snapshotting表面意思为快照方式，即根据配置文件的内容把内存里面的数据写入到二进制文件里，默认为dump.rdb。具体参考配置
文件例如save 300 10意思为如果300秒内超过10个key被修改则进行快照保存。具体步骤为：
1redis先fork，这样就有了父进程与子进程。
2父进程继续接收client的请求，子进程负责将数据写入临时文件中，由于os的写时复制机制（copy on write）这样父进程与子进程
共享同样的物理页面
3这时父进程操作的是一个副本，子进程将数据写入临时文件完成时，副本再代替原来的快照文件。
client也可以用save来使快照持久化，但是由于redis用一个主线程来处理所有的请求，这样其他的clinet就无法请求redis，且redis
采用快照持久化它不是增量的只同步脏数据，他是把所有的数据都从内存写入到磁盘，这样当数据量大io多的话会非常影响性能，且
安全方面也存在隐患，由于是每隔一段时间存到硬盘里，如果redis down掉的话就会丢书修改。

为了防止丢失修改就出现了aof
aof意思为append only file，redis为把接受到的写命令都写入到一个文件中，这样我们在回复redis的时候只需根据这个文件就行，但是
由于已经执行过的写操作，数据可能会缓存到os内核中这样也会丢失修改，为了解决这样一个问题redis进行了一种折衷的方法默认调用
appendfsync everysec方法每秒都会把数据强制写到磁盘中。这样就会引来另外一个问题，如果一直进行写入那么存写命令的这个文件
就会越来越大这时我们可以调用bgrewriteaof命令（background rewrite append only file）这样就相当于对当前文件进行了一次快照
这里就相当于数据，然后把数据转为命令存到文件中这样原来的写命令就转为执行bgrewriteaof的当前数据，然后在接受写命令具体步骤为
1fork redis产生了一个子进程
2子进程将快照的数据写入到日志，然后将日志存入一个临时文件中
3父子进程同时执行，这时子进程将数据写入到一个临时文件中而父进程怎会将接收到的写命令存入到一个缓冲区
4当子进程写临时文件完毕时，会把缓冲区的写入到临时文件中
5临时文件会覆盖掉原来的那个比较大的存放写命令的文件。

这里是为了测试分之使用。
